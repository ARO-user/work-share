import numpy as np
from scipy.misc import factorial
from numpy.polynomial.polynomial import Polynomial as P
from astropy.table import Table
from astropy.time import Time
from astropy.constants import c
import astropy.coordinates as coord
import astropy.units as u
import de405, de421
import jplephem.ephem
import rf_ephem

deg2rad = np.pi/180.

class ELL1Ephemeris(dict):
    """Empheris based on tempo .par file for PSR J0337"""

    def __init__(self, name='psrj1959.par'):
        d, e, f = par2dict(name)
        # make dictionary
        dict.__init__(self, d)
        self.err = e
        self.fix = f

    def evaluate(self, par, mjd, t0par='TASC', integrate=False):
        dt = (mjd-self[t0par])*24.*3600.
        pardot = '{}DOT'.format(par)
        if pardot in self.keys():
            parpol = P([self[par], self[pardot]])
        else:
            parpol = P([self[par]])

        if integrate: parpol = parpol.integ()

        return parpol(dt)

    def mean_anomaly(self, mjd):
        return 2.*np.pi*self.evaluate('FB', mjd, integrate=True)

    def orbital_delay(self, mjd):
        ma = self.mean_anomaly(mjd)
        an = 2.*np.pi*self.evaluate('FB', mjd)
        a1, e1, e2 = self['A1'], self['EPS1'], self['EPS2']
        dre = a1*(np.sin(ma)-0.5*(e1*np.cos(2*ma)-e2*np.sin(2*ma)))
        drep = a1*np.cos(ma)
        drepp = -a1*np.sin(ma)
        d2bar = dre*(1-an*drep+(an*drep)**2+0.5*an**2*dre*drepp)
        if 'M2' in self.keys():
            brace = 1.-self['SINI']*np.sin(ma)
            d2bar += -2.*self['M2']*np.log(brace)
        return d2bar

    def orbital_delay(self, mjd):
        """Delay in s.  Includes higher order terms and Shapiro delay."""
        ma = self.mean_anomaly(mjd)
        an = 2.*np.pi*self.evaluate('FB', mjd)
        a1, e1, e2 = self['A1'], self['EPS1'], self['EPS2']
        dre = a1*(np.sin(ma)-0.5*(e1*np.cos(2*ma)-e2*np.sin(2*ma)))
        drep = a1*np.cos(ma)
        drepp = -a1*np.sin(ma)
        d2bar = dre*(1-an*drep+(an*drep)**2+0.5*an**2*dre*drepp)
        if 'M2' in self.keys():
            brace = 1.-self['SINI']*np.sin(ma)
            d2bar += -2.*self['M2']*np.log(brace)
        return d2bar

    def radial_velocity(self, mjd):
        """Radial velocity in lt-s/s.  Higher-order terms ignored."""
        ma = self.mean_anomaly(mjd)
        an = 2.*np.pi*self.evaluate('FB', mjd)
        a1, e1, e2 = self['A1'], self['EPS1'], self['EPS2']
        vrad = an*a1*(np.cos(ma)+0.5*(e1*np.sin(2*ma)+e2*np.cos(2*ma)))
        return vrad

    def pos(self, mjd):
        ra = self.evaluate('RAJ', mjd, 'POSEPOCH')*deg2rad
        dec = self.evaluate('DECJ', mjd, 'POSEPOCH')*deg2rad
        ca = np.cos(ra)
	sa = np.sin(ra)
	cd = np.cos(dec)
	sd = np.sin(dec)
        return np.array([ca*cd, sa*cd, sd])

def par2dict(name):
    d = {}; e = {}; f = {}
    with open(name, 'r') as parfile:
        for lin in parfile:
            parts = lin.split()
            item = parts[0].upper()
            assert 2 <= len(parts) <= 4
            try:
                value = float(parts[1].lower().replace('d', 'e'))
                d[item] = value
            except ValueError:
                d[item] = parts[1]
            if len(parts) == 4:
                f[item] = int(parts[2])
                e[item] = float(parts[3].lower().replace('d', 'e'))
        # convert RA, DEC
        c = coord.ICRSCoordinates(' '.join([d['RAJ'],d['DECJ']]), 
                                  unit=(u.hr, u.degree))
        d['RAJ'] = c.ra.degrees
        e['RAJ'] = e['RAJ']/15./3600.
        d['DECJ'] = c.dec.degrees
        e['DECJ'] = e['DECJ']/3600.
        if 'PMRA' in d.keys() and 'PMDEC' in d.keys():
            # convert to degrees/s
            conv = (1.*u.mas/u.yr).to(u.deg/u.s).value
            cosdec = np.cos((d['DECJ']*u.deg).to(u.rad).value)
            d['RAJDOT'] = d['PMRA']*conv/cosdec
            e['RAJDOT'] = e['PMRA']*conv/cosdec
            f['RAJDOT'] = f['PMRA']
            d['DECJDOT'] = d['PMDEC']*conv
            e['DECJDOT'] = e['PMDEC']*conv
            f['DECJDOT'] = f['PMDEC']

        if 'FB' not in d.keys():
            d['FB'] = 1./(d['PB']*24.*3600.)
            e['FB'] = e['PB']/d['PB']*d['FB']
            f['FB'] = f['PB']
            if 'PBDOT' in d.keys():
                d['FBDOT'] = d['PBDOT']/d['PB']*d['FB']
                e['FBDOT'] = e['PBDOT']/d['PB']*d['FB']
                f['FBDOT'] = f['PBDOT']
    return d, e, f

class JPLEphemeris(jplephem.ephem.Ephemeris):
    """JPLEphemeris, but including 'earth'"""
    def position(self, name, tdb):
        """Compute the position of `name` at time `tdb`.

        Run the `names()` method on this ephemeris to learn the values
        it will accept for the `name` parameter, such as ``'mars'`` and
        ``'earthmoon'``.  The barycentric dynamical time `tdb` can be
        either a normal number or a NumPy array of times, in which case
        each of the three return values ``(x, y, z)`` will be an array.

        """
        if name == 'earth':
            return self._interpolate_earth(tdb, False)
        else:
            return self._interpolate(name, tdb, False)

    def compute(self, name, tdb):
        """Compute the position and velocity of `name` at time `tdb`.

        Run the `names()` method on this ephemeris to learn the values
        it will accept for the `name` parameter, such as ``'mars'`` and
        ``'earthmoon'``.  The barycentric dynamical time `tdb` can be
        either a normal number or a NumPy array of times, in which case
        each of the six return values ``(x, y, z, dx, dy, dz)`` will be
        an array.

        """
        if name == 'earth':
            return self._interpolate_earth(tdb, True)
        else:
            return self._interpolate(name, tdb, True)

    def _interpolate_earth(self, tdb, differentiate):
        earthmoon_ssb = self._interpolate('earthmoon', tdb, differentiate)
        moon_earth = self._interpolate('moon', tdb, differentiate)
        # earth relative to Moon-Earth barycentre
        # earth_share=1/(1+EMRAT), EMRAT=Earth/Moon mass ratio
        return -moon_earth*self.earth_share + earthmoon_ssb

if __name__ == '__main__':
    eph1957 = ELL1Ephemeris('psrj1959.par')
    jpl405 = JPLEphemeris(de405)
    jpl421 = JPLEphemeris(de421)
    mjd = Time('2013-04-20', scale='utc').mjd+np.linspace(0.,1.,25)
    mjd = Time(mjd, format='mjd', scale='utc', 
               lat=-(74*u.deg+02*u.arcmin+59.07*u.arcsec).to(u.deg).value,
               lon=(19*u.deg+05*u.arcmin+47.46*u.arcsec).to(u.deg).value)
    d_orb = eph1957.orbital_delay(mjd.tdb.mjd)
    pos_earth405 = jpl405.position('earth', mjd.tdb.jd)/c.to(u.km/u.s).value
    d_earth405 = (pos_earth405*eph1957.pos(mjd.tdb.mjd)).sum(axis=0)
    pos_earth421 = jpl421.position('earth', mjd.tdb.jd)/c.to(u.km/u.s).value
    d_earth421 = (pos_earth421*eph1957.pos(mjd.tdb.mjd)).sum(axis=0)
    # now with Fisher's ephemeris
    rf_ephem.set_ephemeris_dir('/data/mhvk/packages/jplephem', 'DEc421')
    #rf_ephem.set_observer_coordinates(0.,0.,0.)
    #GMRT from tempo2-2013.3.1/T2runtime/observatory/observatories.dat
    rf_ephem.set_observer_coordinates(1656318.94, 5797865.99, 2073213.72)
    rf_earth = rf_ephem.pulse_delay(eph1957.evaluate('RAJ',mjd.tdb.mjd[0])/15., 
                                    eph1957.evaluate('DECJ',mjd.tdb.mjd[0]),
                                    int(mjd.utc.mjd[0]), 
                                    mjd.utc.mjd[0]-int(mjd.utc.mjd[0]), 
                                    len(mjd),
                                    (mjd.utc.mjd[1]-mjd.utc.mjd[0])*24.*3600.)
    import matplotlib.pylab as plt
    plt.ion()
    plt.plot(mjd.utc.mjd, d_earth421-rf_earth['delay'])
    plt.draw()
