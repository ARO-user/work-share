from scipy.optimize import leastsq
import numpy as np
from numpy.linalg import eig, inv
import matplotlib.pyplot as plt
import argparse

#This code takes projected semi-major axis, period, longitude of ascending node
#and inclination and plots a circular orbit of a star with those parameters as 
#it would appear on the sky. It then randomizes the generated points and 
#attempts to fit an elliptical orbit back to it using least squares.


#ASSUMPTIONS
#That the orbit of the pulsar is small enough (ie, a is small) that the sky can #be approximated as a plane in that region

#That the semi-major axis lies along the direction of right ascension rather 
#than the declination (when writing initial equation for the ellipse). This is 
#quite unfounded, and I am still thinking about how to fix it.

#That the time of ascending node marks the beginning of an orbit (the beginning
#being when the polar angle is zero)  - there is no reason for this to be the 
#case

#That the errors are constant values, and that the smaller error will be in the #direction of right ascension - again, there is no reason for this to be the 
#case

#OTHER FIXES
#I suspect my use of arrays is unnecessarily complicated and would like to put 
#some time into simplifying them.

#I would like to set up a response that tells you for a given time, how many 
#orbits have passed since the time of ascending node


#Create an command line argument parser. 
parser=argparse.ArgumentParser()

#Add command line options
#Required arguments
parser.add_argument('--i', type=float, required=True, help=''' The inclination of the orbit in radians.''')
parser.add_argument('--l', type=float, required=True, help=''' The longitude of the ascending node in radians''')
parser.add_argument('--T', type=float, required=True, help=''' The period of the orbit in seconds. ''')
parser.add_argument('--a', type=float, required=True, help=''' The length of the projected semi-major axis of the system in arcseconds.''')


#Optional arguments
parser.add_argument('--t_0', type=float, default=0, help=''' The time of ascending node in seconds.''') 
#time of ascending node defaults to zero for the sake of simplicity
parser.add_argument('--time', type=float, help=''' A time in the orbit relative to the time of ascending node.''')
#time defaults to an interval below
parser.add_argument('--meas', type=int, default=10, help=''' The number of equally spaced measurements taken over the course of one orbit.''')
#number of measurements per orbit defaults to 10
parser.add_argument('--orb', type=float, default=1, help=''' The number of orbits the star completes. Default value is one.''')
#number of orbits defaults to 1
parser.add_argument('--rapm', type=float, default=0, help=''' The proper motion of the orbit in the direction of right ascension''')
parser.add_argument('--decpm', type=float, default=0, help=''' The proper motion of the orbit in the direction of declination''')
#proper motion in either direction defaults to zero

#Parse the command line arguments
args=parser.parse_args()

#Defining variables from input
i=args.i #inclination
l=args.l #longitude of ascending node
P=args.T #period of orbit
maj=args.a #projected semi major axis
n=args.meas #number of orbit
t_0=args.t_0 #time of ascending node
time=args.time 
#a particular time at which the orbital position is to be predicted
orb=args.orb #number of orbits to be simulated
ra_pm=args.rapm #proper motion in the direction of right ascension
dec_pm=args.decpm #proper motion in the direction of declination

if time==None: #if no specific time is specified
    time=np.linspace(t_0,(orb*2*P*np.pi)+t_0,n*orb)
    #set time to be the interval from time of ascending node to the specified 
    #number of orbital periods later, divided into 'n' measurements per orbit

#QUESTION 1 - PLOTTING AN ORBIT

#Define a function that take time, initial time, semi-major axis, period, proper
#motion in the directions of right ascension and declination, inclination and 
#longitude of ascending node and creates a list of points in the orbit
def apparent_orbit(t,ti,a,p,v,u,ang,rot):
    output=[] #Create an empty list to hold output
    b=a*np.cos(ang)
    #Define the minor axis of the ellipse in terms of the major axis and the 
    #inclination 
    x=a*np.cos((t-ti)/p) #Write basic parametric equations for an ellipse
    y=b*np.sin((t-ti)/p)
    #Now rotate the ellipse according to the longitude of the ascending node 
    #and incorporate the proper motion
    mod_x=-x*np.sin(rot)+y*np.cos(rot)+v*(t-ti)
    mod_y=x*np.cos(rot)+y*np.sin(rot)+u*(t-ti)
    point=[mod_x,mod_y] #Define a point as being final x and y values
    output.append(point)
    return output

#recover a list of points from the fuction
points=np.array(apparent_orbit(time,t_0,maj,P,ra_pm,dec_pm,i,l))
ra=points[:,0] #divide the list into right ascension
dec=points[:,1] #and declination angles


try: 
    len(time) 
    #if time is an interval, rather than a single value, plot the orbit
    plt.plot(ra,dec,'o',color='blue')
    plt.xlabel('right ascension relative to the centre of orbit in arcseconds')
    plt.ylabel('declination relative to the centre of orbit in arcseconds')
#if time is a single value, print the right ascension and declination at
#that time
except TypeError:
    print 'The right ascension relative to the centre of orbit is:'
    print str(ra[0]) + ' arcseconds'
    print 'The declination relative to the centre of orbit is:'
    print str(dec[0]) + ' arcseconds'
    

#QUESTION 2 - RANDOMIZE THE VALUES IN THE ELLIPSE


#Randomizing x and y
def Randomize(x,y):
    output=[] #Create an empty list to hold output
    #Choose random modified x and y from a Gaussian centred at the original 
    #point with an standard deviation specified by 'scale' - essentially, choose 
    #a point within the errors of the original one.
    mod_x=np.random.normal(loc=x,scale=1e-10)
    mod_y=np.random.normal(loc=y,scale=1e-7)
    point=[mod_x,mod_y]
    output.append(point)
    return output

values=np.array(Randomize(ra,dec)) #recover a list of points from the function

#slice the list into right ascension and declination
ran_ra=values[:,0]
ran_ra=ran_ra[:,0] 
ran_ra=ran_ra[0]#randomized right ascension

ran_dec=values[:,1]
ran_dec=ran_dec[:,0] 
ran_dec=ran_dec[0]#randomized declination

#QUESTION 3 - FIT AN ELLIPSE TO RANDOM DATA

p0=[1,1]

def residuals_y(p,y,t):
    ang,rot=p
    mi=maj*np.cos(ang)
    el_x=maj*np.cos((t-t_0)/P)
    el_y=mi*np.sin((t-t_0)/P)
    mod_y=el_x*np.cos(rot)+el_y*np.sin(rot)+dec_pm*(t-t_0)
    err=y-mod_y
    return err

def residuals_x(p,x,t):
    ang,rot=p
    mi=maj*np.cos(ang)
    el_x=maj*np.cos((t-t_0)/P)
    el_y=mi*np.sin((t-t_0)/P)
    mod_x=-el_x*np.sin(rot)+el_y*np.cos(rot)+ra_pm*(t-t_0)
    err=x-(mod_x)
    return err

plsqy=leastsq(residuals_y,p0,args=(ran_dec,time))

plsqx=leastsq(residuals_x,p0,args=(ran_ra,time))

plsq=(plsqx[0]+plsqy[0])/2

print 'The predicted inclination is ' + str(plsq[0])+ ' radians'
print 'The predicted longitude of ascending node is ' +str(plsq[1])+ ' radians' 


time=np.arange(t_0,(orb*2*P*np.pi)+t_0,0.001)
points=np.array(apparent_orbit(time,t_0,maj,P,ra_pm,dec_pm,plsq[0],plsq[1]))
ra=points[:,0] 
dec=points[:,1] 


fig=plt.figure()
ax=fig.add_subplot(111)
ax.plot(ra,dec)
plt.show()
