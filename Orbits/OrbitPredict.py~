from scipy.optimize import leastsq
import numpy as np
from numpy.linalg import eig, inv
import matplotlib.pyplot as plt
import argparse

#Create an command line argument parser. 
parser=argparse.ArgumentParser()

#Add command line options
#Required arguments
parser.add_argument('--T', type=float, required=True, help=''' The period of the orbit in seconds. ''')
parser.add_argument('--a', type=float, required=True, help=''' The length of the projected semi-major axis of the system in arcseconds.''')


#Optional arguments
parser.add_argument('--t_0', type=float, default=0, help=''' The time of ascending node in seconds.''') 
#time of ascending node defaults to zero for the sake of simplicity
parser.add_argument('--time', type=float, help=''' A time in the orbit relative to the time of ascending node.''')
#time defaults to an interval below
parser.add_argument('--meas', type=int, default=10, help=''' The number of equally spaced measurements taken over the course of one orbit.''')
#number of measurements per orbit defaults to 10
parser.add_argument('--orb', type=float, default=1, help=''' The number of orbits the star completes. Default value is one.''')
#number of orbits defaults to 1
parser.add_argument('--rapm', type=float, default=0, help=''' The proper motion of the orbit in the direction of right ascension''')
parser.add_argument('--decpm', type=float, default=0, help=''' The proper motion of the orbit in the direction of declination''')
#proper motion in either direction defaults to zero

#Parse the command line arguments
args=parser.parse_args()

#Defining variables from input
P=args.T #period of orbit
maj=args.a #projected semi major axis
n=args.meas #number of orbit
t_0=args.t_0 #time of ascending node
time=args.time 
#a particular time at which the orbital position is to be predicted
orb=args.orb #number of orbits to be simulated
ra_pm=args.rapm #proper motion in the direction of right ascension
dec_pm=args.decpm #proper motion in the direction of declination

if time==None: #if no specific time is specified
    time=np.linspace(t_0,(orb*2*P*np.pi)+t_0,n*orb)
    #set time to be the interval from time of ascending node to the specified 
    #number of orbital periods later, divided into 'n' measurements per orbit

#Need ra,raerr,dec,decerr from input file

#QUESTION 2 - RANDOMIZE THE VALUES IN THE ELLIPSE

n=0 #an index representing the number of times the fitter has run
parameters=[] #an empty list to hold the results of each iteration

#Run the fitter 100 times
while n<=100:

#Randomizing x and y
    
    #Choose random modified x and y from a Gaussian centred at the original 
    #point with an standard deviation specified by 'scale' - essentially, choose
    #a point within the errors of the original one.
    
    def Randomize(x,y):
        mod_x=np.random.normal(loc=x,scale=1e-10)
        mod_y=np.random.normal(loc=y,scale=1e-7)
        return (mod_x,mod_y)

#recover a list of points from the function
    values=np.array(Randomize(ra,dec)) 

#slice the list into right ascension and declination
    ran_ra=values[0]#randomized right ascension
    ran_dec=values[1]#randomized declination


#QUESTION 3 - FIT AN ELLIPSE TO RANDOM DATA

#A function that calculates the difference between input y values and the y 
#values of an ellipse with parameters ang and rot, two angles that describe its
#eccentricity and rotation around the origin, respectively
#residuals_y takes two parameters, y-values, and time and returns a list
    
    def residuals_y(p,y,t):
    #ang and rot are two angles described in the parameter list p
        ang,rot=p
    #the minor axis of the ellipse is related to the major axis by the following
        mi=maj*np.cos(ang)
    #basic parametric equations for an ellipse
        el_x=maj*np.cos((t-t_0)/P)
        el_y=mi*np.sin((t-t_0)/P)
    #modfied y value that has been rotated around the origin and had proper 
    #motion incorporated
        mod_y=el_x*np.cos(rot)+el_y*np.sin(rot)+dec_pm*(t-t_0)
    #the difference between the input y values and y values on an ellipse
        err=y-mod_y
        return err

#A function that calculates the difference between input x values and the x 
#values of an ellipse with parameters ang and rot, two angles that describe its
#eccentricity and rotation around the origin, respectively
#residuals_x takes two parameters, x-values and time and returns a list
    
    def residuals_x(p,x,t):
    #ang and rot are two angles described in the parameter list p
        ang,rot=p
    #the minor axis of the ellipse is related to the major axis by the following
        mi=maj*np.cos(ang)
    #basic parametric equations for an ellipse
        el_x=maj*np.cos((t-t_0)/P)
        el_y=mi*np.sin((t-t_0)/P)
    #modified x value that has been rotated around the origin and had proper 
    #motion incorporated
        mod_x=-el_x*np.sin(rot)+el_y*np.cos(rot)+ra_pm*(t-t_0)
    #the difference between the input x values and the x values on an ellipse
        err=x-mod_x
        return err

#initial guess for parameters. p0[0] is inclination, p0[1] is longitude
#this guess is used by the leastsq function
    p0=[float(raw_input('leastsq needs a guess to run. What is a likely inclination angle?'),float(raw_input('And the longitude of ascending node?')

#minimize the squares of the y residuals, taking input y to be the randomized 
#declination and the guess as given above
#returns an array of the two predicted parameters
    dec_lsq=leastsq(residuals_y,p0,args=(ran_dec,time))

#minimize the squares of the x residuals, taking input x to be the randomized 
#right ascension and the guess as given above
#returns an array of the two predicted parameters
    ra_lsq=leastsq(residuals_x,p0,args=(ran_ra,time))

#take the average of the parameters generates by the optimizing leastsq function
    lsq=np.array((ra_lsq[0]+dec_lsq[0])/2)
#divide lsq into inclination and longitude    
    inclination=lsq[0]
    longitude=lsq[1]
#add each pair to parameters list
    values=[inclination, longitude]
    parameters.append(values)
#increment n to continue to the next iteration
    n+=1

#Extract inclination and longitude into separate lists total_inc and total_long
total_inc=[]
total_long=[]
for i in range(len(parameters)):
    total_inc.append(parameters[i][0])
    total_long.append(parameters[i][1])

#Average each list to find the values for inclination and longitude found by 
#the fitter
inclination = sum(total_inc)/len(total_inc)
longitude = sum(total_long)/len(total_long)

#Calculate the standard deviation over the dataset
inc_error=[]
long_error=[]
for j in range(len(parameters)):
    inc_error.append(abs(total_inc[j]-inclination))
    long_error.append(abs(total_long[j]-longitude))

inclination_error = sum(inc_error)/len(inc_error)
longitude_error = sum(long_error)/len(long_error)

#Print the results to the shell
print ''
print 'The inclination is: '
print str(inclination) + '+/-' + str(inclination_error)
print ''
print 'The longitude of ascending node is: '
print str(longitude) + '+/-' + str(longitude_error)

